# The function c() is a basic function that groups together numbers
# or character strings.
# The "<-" sign ("less than" sign, minus sign) will assign our group
# of numbers to an object name. An object name is used to
# succinctly refer to data. We'll call this "mat.input.v"
mat.input.v <- c(9, 56, 72, 4, 862, 263, 93, 49, 152)
c(9, 56, 72, 4, 862, 263, 93, 49, 152)
mat.input.v
# The matrix() function is used to form a matrix. Let's look at its help file.
?matrix
sample.data.mat <- matrix(data=mat.input.v, nrow=3)
# In RStudio, press tab after matrix(  to get arguments
sample.data.mat
# Let's change the default argument for "byrow"
sample.data.mat <- matrix(data=mat.input.v, nrow=3, byrow=TRUE)
sample.data.mat
# You can set arguments by name (what we just did) or by
# the order in which they appear
matrix(mat.input.v, 3)
# TYPES OF OBJECTS
# There are four basic types of objects in R.
# You have already seen two of them: a vector and a matrix.
# Let's explore the vector in more detail.
# Much of the terminology is R is based on linear algebra concepts
# So an ordered set of numbers or character strings is called a vector
# It's better to think of vector as an ordered set rather than a
# matrix with one column or one row since vectors in R have only one dimension.
# There are many ways to create a vector or extract a vector from
# another object. We used the c() function to create mat.input.v
mat.input.v
# We can use the ":" operator to create a vector of all the integers
# that exist between two integers, inclusive.
one.hundred.v<-1:100
one.hundred.v
# Let's look at a way to extract a vector from a dataset.
# The read.csv() function is going to be your primary way to get
# A dataset into your R workspace
net.worth.df<-read.csv("http://www.opensecrets.org/db2dl/?q=PFDsWorth&cycle=2008&output=CSV", stringsAsFactors=FALSE)
# Data on net worth of Congresspeople, Supreme Court Justices,
# and certain executive branch officials
?read.csv
# You do not want to deal with "factors" until you get good at R, so we will not
# convert character strings to factors.
# (R uses factors to deal with categorical data, but in most circumstances
# character data can behave like categorical data.)
# What did we just load? There are two main ways to examine what we have.
View(net.worth.df)
str(net.worth.df)
# What if we want to just extract one column and make it into a vector?
# There are two ways to do this. One way is:
congress.ppl.names.v<-net.worth.df$Name
# str() is indispensible when working your way through a data project.
# It can be used on any type of object, including a vector
str(congress.ppl.names.v)
# Another way to extract the column is:
congress.ppl.names.v<-net.worth.df[, "Name"]
# If we are unsure if two operations produce the exact same object,
# we can use identical()
identical(net.worth.df$Name, net.worth.df[, "Name"])
# What is up with these square brackets? Recall that R concepts are
# usually based on linear algebra. This is subscript notation, and
# it is a key concept in R that you will use constantly. It is saying:
# object.name[select row(s), select column(s)]
# Rows are always before the comma and columns after.
# If the space before or after the comma is blank, R assumes that you
# want all the rows or all the columns.
# Unlike with the "$" operator, subscripts can be used to get more than
# one column from a dataframe, although this makes a dataframe
# rather than just a vector
name.and.chamber.df<-net.worth.df[, c("Name", "chamber")]
str(name.and.chamber.df)
# You can select rows and columns by using numeric vectors or
# logical vectors. Character vectors are mostly just for getting columns.
# Get first 5 rows
net.worth.df[1:5, c("Name", "AvgValue")]
# Exclude first 640 rows
net.worth.df[ -(1:640), c("Name", "AvgValue")]
# Only get those observations/records where the net worth is
# greater than 100,000,000
net.worth.df[net.worth.df$AvgValue>100000000, c("Name", "AvgValue")]
net.worth.df[net.worth.df$AvgValue>100000000, ]
# What is going on here? First a logical vector is produced and then
# it is fed into the subscript
net.worth.df$AvgValue>100000000
net.worth.df[net.worth.df$chamber %in% c("E", "J"), ]
# Only get the people who are in the execuitive or judicial branches
# The %in% function asks:
# "Which elements of net.worth.df$chamber are in the set c("E", "J")?"
# Not only will subscripting get you only the rows that you request,
# but if you use a numeric vector it will get you the rows in that order
net.worth.df[1:4, c("Name", "AvgValue")]
net.worth.df[4:1, c("Name", "AvgValue")]
net.worth.df[4:1, c("AvgValue", "Name")]
# This feature is used to sort datasets by columns, using order()
net.worth.df[order(net.worth.df$Name), c("Name", "AvgValue")]
# WARNING: sort() is not for sorting dataframes
# Until now, we have assigned stuff to new objects
# We can also assign stuff to parts of already-existing objects
net.worth.df$chamber[net.worth.df$chamber=="S"] <- "Senate"
net.worth.df$chamber[net.worth.df$chamber=="H"] <- "House"
# This says, "For all elements of the chamber column such that the value
# of chamber is 'S', replace those elements with 'Senate'"
# This is an equilivalent operation:
net.worth.df[net.worth.df$chamber="S", "chamber"] <- "Senate"
# Why? Be precise.
1:1000
# We can name everything
greeks.v<- 1:5
greeks.v
names(greeks.v) <- c("alpha", "beta", "gamma", "delta", "epsilon")
greeks.v
greeks.v["gamma"]
# And then access the values by name
# Big change from MATLAB
colnames(sample.data.mat) <- c("id", "gdp", "pop")
rownames(sample.data.mat) <- c("a", "b", "c")
sample.data.mat
sample.data.mat["b", "pop"]
# Almost every object or result of a function can be used as an input
# for a function. The standard parethetical order of operations prevails,
# i.e. the innermost function is evaluated first.
nrow(net.worth.df)
nrow(net.worth.df)/100
round(nrow(net.worth.df)/100)
rep("test", times=round(nrow(net.worth.df)/100))
# Building up the operation one step at a time
tt<-nrow(net.worth.df)
mm<-tt/100
bb<-round(mm)
rep("test", times=bb)
# My personal style is more the first example - everything evaluated
# at once on one line, within reason.
# Let's stop for a sec to note some important details:
# 1. All object names and functions are case-sensitive
# sample.df does not equal Sample.df
one.hundred.v
One.Hundred.V
# 2. Allowable object and function names can include letters,
# numbers, periods, and underscores. No spaces are allowed in these names.
# 3. Adding ".df", ".mat", or ".v" is unnecessary. This is my personal
# style. I find it useful since you often have the same data in different
#	forms and keeping track of what all your objects are can be hard without
# these identifiers
# 4. Spaces between object names and operators are ignored. Spaces
# are useful for making your code clear and readable to others and yourself
matrix(data=mat.input.v, nrow=3)
# is the same as
matrix(  data=mat.input.v  , nrow =  3)
# You can even do this
chambers.mat <- matrix  (net.worth.df$   chamber)
# But don't do that since it makes the code confusing to the reader
# 5. If R thinks that a statement continues on the next line,
# it will interpret it the same as one statement on one line
matrix(data=mat.input.v,
nrow=3)
TRUE & TRUE & FALSE &
FALSE
# You must give it a reason to think the operation continues, though
3 + log(10)
* 35
# 6. Conversion between object types and data formats is
# straighforward, but be careful.
as.data.frame(sample.data.mat)
as.logical(c(1, 0, 0, 1, 0))
as.numeric(c("2", "4", "90", "junk", "24"))
# Flow control features
if (nrow(net.worth.df) > 400) {
cat("yup")
}
# The cat() function just prints character strings to the console
if (nrow(net.worth.df) < 400) {
cat("yup")
} else {
cat("nope")
}
for ( i in 1:nrow(net.worth.df)) {
cat("Print this", i, "\n")
}
# R has a full suite of flow control features like while, break, next, etc.
# Constructing functions
# Basic structure of a function:
# function name <- function( argument names ) {
#   do stuff
#   last line is the output
# }  Î³
VV.line.fn<-function(rho, sigma, n, alpha) {
A <- ifelse(n <= 1, alpha, 1-alpha)
A/(rho*sigma*n)
}
# This function is basically just an arithmetic operation, but
# keep in mind that you can get much more creative with writing functions
n.sequence <- seq(0, 6, length.out=6*30)
VV.line <- VV.line.fn(rho=.95, sigma=3.2, n=n.sequence,  alpha=.14)
plot(n.sequence, VV.line, type="l", col="red", ylim=c(0,.4))
# We have covered matrices, dataframes, and vectors.
# There is a fourth basic data type: Lists
# Lists are the most foreign idea for STATA and MATLAB users
# A list is a structured, possibly hierarchical, collection of objects
# Don't think of list as in shopping list
kitchen.sink.ls <- list(sample.data.mat, one.hundred.v, net.worth.df[1:5, ])
kitchen.ls <- list(c("stove", "fridge", "toaster"), kitchen.sink.ls)
str(kitchen.ls)
kitchen.sink.ls[[2]]
# Gets the 2nd element of the list
kitchen.sink.ls[1:2]
# Makes a list containing the 1st and 2nd element of this list
# Unlike in MATLAB, function always return a single object in R
# In MATLAB:
# function[average, st_dev] =  summary_stats(x)
#   average = mean(x);
#   st_dev = sd(x);
# end
# In R, we would pack our results into a list
summary_stats <- function(x) {
ret<-list()
# Initiate a list object (create an empty list)
ret$average <- mean(x)
ret$st_dev <- sd(x)
ret
}
summary_stats(rnorm(500))
# Unlike in MATLAB, you do not need to put your functions into a separate file.
# R stores the function as it reads your script file.
# If you choose to, you can put functions in a separate file from your analysis file,
# but you must ask R to read the functions with source() before running your analysis.
# <INTERLUDE: GO TO SLIDES>
co2.df<-read.csv("http://hci.stanford.edu/jheer/workshop/data/worldbank/worldbank.csv", stringsAsFactors=FALSE)
colnames(co2.df)<-c("country", "year", "co2.emissions.per.cap", "electric.consumption", "total.energy.use", "fertility", "gdp", "internet.users", "life.exp", "military.exp.perc.gdp", "population", "hiv.rate")
# Rename column names to make them shorter
lm(co2.emissions.per.cap ~ gdp + log(gdp) + military.exp.perc.gdp + internet.users,  data=co2.df)
# Is that all R knows about this model?
summary( lm(co2.emissions.per.cap ~ gdp + log(gdp) + military.exp.perc.gdp + internet.users,  data=co2.df))
co2.lm <- lm(co2.emissions.per.cap ~ gdp + log(gdp) + military.exp.perc.gdp + internet.users,  data=co2.df)
# The co2.lm object is a list
str(co2.lm)
co2.lm$coefficients
# Access the coeficient values with the list syntax
coef(co2.lm)
# Or through the coef() function for convenience
# Let's tabulate things
table(co2.df$year)
# Since our data is continuous, hard to have sensible cross tabulations.
# Let's just tabulate the number of countries with GDP > 3000 by country.
table(co2.df$year, co2.df$gdp>3000)
aggregate(co2.df$co2.emissions.per.cap, by=list(co2.df$year), FUN=sum, na.rm=TRUE)
# NOTE: The "by" argument must be a list, not just a vector
# Why do we write na.rm=TRUE when aggregate() has no such argument named na.rm?
aggregate(co2.df[, c("co2.emissions.per.cap", "gdp")],
by=list(co2.df$year, round(co2.df$fertility)),
FUN=sum, na.rm=TRUE)
# aggregate() is actually quite general, and any function, not just sum(), can be applied to a group of observations
plot(log(co2.df[co2.df$year==2000, "gdp"]),
log(co2.df[co2.df$year==2000, "co2.emissions.per.cap"]),
col="transparent")
# No points are actually plotted here, since color is set to "transparent".
# This just sets up the plot area.
text(log(co2.df[co2.df$year==2000, "gdp"]),
log(co2.df[co2.df$year==2000, "co2.emissions.per.cap"]),
labels=substr(co2.df[co2.df$year==2000, "country"], 1, 2),
cex=.7)
# Let's show off some of the power of R's syntax.
# Interpolating missing data for life expectancy by country:
imputed.co2.ls <- by(co2.df,  INDICES=co2.df$country, FUN=function(x) {
if (sum(is.na(x$life.exp))==6) {return(x)}
# If all life expectancy data is missing, we cannot interpolate, so
# we return the original data frame
x.lm<-lm( log(life.exp) ~ year, data=x)
# Fit a regression, with the logarithm of life expectancy predicted by year
missing.years.df <- data.frame( year = x$year[is.na(x$life.exp)] )
# Create a new data frame with the year variable being the missing years
# of the original data frame.
x.pred <- predict(x.lm, newdata=missing.years.df)
# Predict the missing values based on the regression model
x$life.exp[is.na(x$life.exp)]  <- exp(x.pred)
# Turn the predicted life expectancy, which is in logarithm, back to actual years
x
# Return the modified data frame
}
)
# by() returns a list
str(imputed.co2.ls)
imputed.co2.ls[["Belarus"]]
imputed.co2.df <- do.call(rbind, imputed.co2.ls)
??"standard deviation"
getwd()
ls()
with(co2.df, fertility + life.exp * internet.users / log(gdp))
# Easier-to-read syntax if you have lots of operations with a single data frame
?data.frame
as.numeric(1L)
as.numeric(1L) * 1000000000
1L * 1000000000
1L * 1000000000L
1L * 100000000000L
1L * 1000000000000000
100000L * 100000000L
type(1)
typeof(1)
typeof(1L)
100000000L
100000000
typeof(1:10)
100000000L^1000
100000000L^100
100000000L^10
10^309
10^308
setwd("/Users/travismcarthur/git/slidify-presentations/slidify-presentations-pages/r-intro/)
setwd("/Users/travismcarthur/git/slidify-presentations/slidify-presentations-pages/r-intro/")
slidify("/Users/travismcarthur/git/slidify-presentations/slidify-presentations-pages/r-intro/index.Rmd")
c.exp.df<-read.dta("/Users/travismcarthur/Desktop/TAA research/consumer exp/intrvw12/fmli121x.dta")
library(foreign)
c.exp.df<-read.dta("/Users/travismcarthur/Desktop/TAA research/consumer exp/intrvw12/fmli121x.dta")
c.exp.df<-read.dta("/Users/travismcarthur/Desktop/Misc Phd research/TAA research/consumer exp/intrvw12/fmli121x.dta")
names(c.exp.df)
c.exp.df$newid
getwd()
c.exp.df[1:10, 1:5]
year <-12
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "2.dta"))
work.dir<-"/Users/travismcarthur/Desktop/Misc Phd research/TAA research/consumer exp"
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "2.dta"))
paste(year, 2:4)
c(paste0(year, 2:4), paste0(year+1, 1))
?vecyor
?vector
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "2.dta"))
c.exp.ids <- c.exp.for.ids.df[
c.exp.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.df$high_edu %in% c( "15", "16"), "newid"]
c.exp.list<-list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
temp.c.exp.list<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.list[[i]] <- temp.c.exp.list[temp.c.exp.list$newid %in% c.exp.ids, ]
}
c.exp.df<-do.call(rbind, c.exp.list)
dim(c.exp.df)
dim(temp.c.exp.list)
dim( c.exp.list[[i]] )
dim( c.exp.list[[2]] )
dim( c.exp.list[[1]] )
dim( c.exp.list[[3]] )
paste0(work.dir, "/intrvw", year, "/fmli", year, "2.dta")
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "3.dta"))
c.exp.ids <- c.exp.for.ids.df[
c.exp.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.df$high_edu %in% c( "15", "16"), "newid"]
c.exp.list<-list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
temp.c.exp.list<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.list[[i]] <- temp.c.exp.list[temp.c.exp.list$newid %in% c.exp.ids, ]
}
c.exp.df<-do.call(rbind, c.exp.list)
nrows(c.exp.df)
nrow(c.exp.df)
nrow(c.exp.list[[1]])
nrow(c.exp.list[[2]])
nrow(c.exp.list[[3]])
nrow(c.exp.list[[4]])
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "3.dta"))
c.exp.ids <- c.exp.for.ids.df[
c.exp.for.ids.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.for.ids.df$high_edu %in% c( "15", "16"), "newid"]
c.exp.list<-list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
temp.c.exp.list<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.list[[i]] <- temp.c.exp.list[temp.c.exp.list$newid %in% c.exp.ids, ]
}
c.exp.df<-do.call(rbind, c.exp.list)
nrow(c.exp.df)
nrow(c.exp.list[[1]])
nrow(c.exp.list[[2]])
nrow(c.exp.list[[3]])
nrow(c.exp.list[[4]])
c.exp.ids
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
temp.c.exp.list<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.list[[i]] <- temp.c.exp.list  # [temp.c.exp.list$newid %in% c.exp.ids, ]
}
c.exp.df<-do.call(rbind, c.exp.list)
table(duplicated(c.exp.df$newid))
names(c.exp.df)
names(c.exp.df)=="cuid"
table(names(c.exp.df)=="cuid")
c.exp.for.ids.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", year, "2.dta"))
c.exp.ids <- c.exp.for.ids.df[
c.exp.for.ids.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.for.ids.df$high_edu %in% c( "15", "16"), "cuid"]
c.exp.list<-list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
temp.c.exp.list<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.list[[i]] <- temp.c.exp.list[temp.c.exp.list$cuid %in% c.exp.ids, ]
}
c.exp.df<-do.call(rbind, c.exp.list)
nrow(c.exp.df)
nrow(c.exp.list[[1]])
nrow(c.exp.list[[2]])
nrow(c.exp.list[[3]])
nrow(c.exp.list[[4]])
median(c.exp.comp.df$apparcq[c.exp.comp.df$apparcq>0], na.rm=TRUE)
median(c.exp.comp.df$apparpq[c.exp.comp.df$apparpq>0], na.rm=TRUE)
c.exp.comp.df<-c.exp.df
median(c.exp.comp.df$apparcq[c.exp.comp.df$apparcq>0], na.rm=TRUE)
median(c.exp.comp.df$apparpq[c.exp.comp.df$apparpq>0], na.rm=TRUE)
year <-12
full.yr.medians.ls <- list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
# Data dictionary at http://www.bls.gov/cex/2012/csxintvwdata.pdf
median.exp.ls <-list()
c.exp.temp.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.subset.df <- c.exp.temp.df[
c.exp.temp.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.temp.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.temp.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.temp.df$high_edu %in% c( "15", "16"), ]
# Housing costs, including utilities, etc.
median.exp.ls[["houscq"]] <- median(c.exp.comp.df$houscq[c.exp.comp.df$houscq>0], na.rm=TRUE)
# length(c.exp.comp.df$fdhomecq[c.exp.comp.df$fdhomecq>0])
#FDHOMECQ
# Food at home current quarter
median.exp.ls[["fdhomecq"]] <- median(c.exp.comp.df$fdhomecq[c.exp.comp.df$fdhomecq>0], na.rm=TRUE)
# length(c.exp.comp.df$fdhomecq[c.exp.comp.df$fdhomecq>0])
# Food away from home current quarter
median.exp.ls[["fdawaycq"]] <- median(c.exp.comp.df$fdawaycq[c.exp.comp.df$fdawaycq>0], na.rm=TRUE)
# length(c.exp.comp.df$fdawaycq[c.exp.comp.df$fdawaycq>0])
# APPARCQ Apparel and services this quarter
median.exp.ls[["apparcq"]] <- median(c.exp.comp.df$apparcq[c.exp.comp.df$apparcq>0], na.rm=TRUE)
# length(c.exp.comp.df$apparcq[c.exp.comp.df$apparcq>0])
# TRANSCQ: Transportation this quarter: CARTKNPQ + CARTKUPQ + OTHVEHPQ + GASMOPQ + VEHFINPQ + MAINRPPQ + VEHINSPQ + VRNTLOPQ + PUBTRAPQ
median.exp.ls[["transcq"]] <- median(c.exp.comp.df$transcq[c.exp.comp.df$transcq>0], na.rm=TRUE)
full.yr.medians.ls[[i]] <- as.data.frame(median.exp.ls)
}
full.yr.medians.df<- do.call(rbind, full.yr.medians.ls)
full.yr.medians.df
year <-12
full.yr.medians.ls <- list()
for (i in c(paste0(year, 2:4), paste0(year+1, 1)) ) {
# Data dictionary at http://www.bls.gov/cex/2012/csxintvwdata.pdf
median.exp.ls <-list()
c.exp.temp.df<-read.dta(paste0(work.dir, "/intrvw", year, "/fmli", i, ".dta"))
c.exp.subset.df <- c.exp.temp.df[
c.exp.temp.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.temp.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.temp.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.temp.df$high_edu %in% c( "15", "16"), ]
# Housing costs, including utilities, etc.
median.exp.ls[["houscq"]] <- median(c.exp.subset.df$houscq[c.exp.subset.df$houscq>0], na.rm=TRUE)
# length(c.exp.subset.df$fdhomecq[c.exp.subset.df$fdhomecq>0])
#FDHOMECQ
# Food at home current quarter
median.exp.ls[["fdhomecq"]] <- median(c.exp.subset.df$fdhomecq[c.exp.subset.df$fdhomecq>0], na.rm=TRUE)
# length(c.exp.subset.df$fdhomecq[c.exp.subset.df$fdhomecq>0])
# Food away from home current quarter
median.exp.ls[["fdawaycq"]] <- median(c.exp.subset.df$fdawaycq[c.exp.subset.df$fdawaycq>0], na.rm=TRUE)
# length(c.exp.subset.df$fdawaycq[c.exp.subset.df$fdawaycq>0])
# APPARCQ Apparel and services this quarter
median.exp.ls[["apparcq"]] <- median(c.exp.subset.df$apparcq[c.exp.subset.df$apparcq>0], na.rm=TRUE)
# length(c.exp.subset.df$apparcq[c.exp.subset.df$apparcq>0])
# TRANSCQ: Transportation this quarter: CARTKNPQ + CARTKUPQ + OTHVEHPQ + GASMOPQ + VEHFINPQ + MAINRPPQ + VEHINSPQ + VRNTLOPQ + PUBTRAPQ
median.exp.ls[["transcq"]] <- median(c.exp.subset.df$transcq[c.exp.subset.df$transcq>0], na.rm=TRUE)
full.yr.medians.ls[[i]] <- as.data.frame(median.exp.ls)
}
full.yr.medians.df<- do.call(rbind, full.yr.medians.ls)
full.yr.medians.df
c.exp.df[1:10 , c("newid", "cuid")]
?substr
substr(x=c.exp.df[1:10 , c("newid")], start=7, stop=7)
c(paste0(year, 2:4), paste0(year+1, 1))
c(paste0(2010:2012, 2:4), paste0( ( 2010:2012)+1, 1))
?rep
paste0( rep(2010:2012 each=4), 2:4)
paste0( rep(2010:2012, each=4), 2:4)
paste0( rep(10:12, each=5), c("1x", 2:4, 1)
)
paste0( rep(10:12, each=5), c(1, "1x", 2:4) )
work.dir <- "/Users/travismcarthur/Desktop/Misc Phd research/TAA research/consumer exp/intrvw10-12"
interview <- c( paste0( rep(10:12, each=5), c(1, "1x", 2:4) )[-1], "131x")
length(interview)
interview
interview.round <- c( paste0( rep(10:12, each=5), c(1, "1x", 2:4) )[-1], "131x")
# 12 cohorts
cohort <- 1
paste0(work.dir, "/fmli", interview.round[cohort], ".dta")
c.exp.temp.df<-read.dta(paste0(work.dir, "/fmli", interview.round[cohort], ".dta"))
c.exp.ids <- c.exp.for.ids.df[
c.exp.for.ids.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.for.ids.df$high_edu %in% c( "15", "16") &
substr(x=c.exp.for.ids.df$newid, start=7, stop=7)==1
, "cuid"]
c.exp.ids
[1:10]
c.exp.for.ids.df$newid[1:10]
interview.round[cohort]
table(substr(x=c.exp.for.ids.df$newid, start=7, stop=7))
c.exp.ids <- c.exp.for.ids.df[
c.exp.for.ids.df$inclass %in% c("02", "03", "04") &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) <= 35 &
rowMeans(c.exp.for.ids.df[, c("age_ref", "age2")], na.rm = TRUE) >= 22 &
c.exp.for.ids.df$high_edu %in% c( "15", "16") &
substr(x=c.exp.for.ids.df$newid, start=7, stop=7)==2
, "cuid"]
c.exp.ids
